//! A menu bar.
//!
//! *This API requires the following crate features to be activated: `menu`*
use std::hash::Hash;

use iced_graphics::{Point, Size};
use iced_native::{
    event, layout, mouse, overlay, row, touch, Clipboard, Element, Event, Layout, Length, Row,
    Widget,
};

use iced_aw::core::renderer::DrawEnvironment;

use super::overlay::cell_overlay::Cell2Overlay;

/// A menu bar.
///
/// # Example
/// ```
/// # use iced_aw::menu::{State, Section, Entry};
/// # use iced_native::{Text, renderer::Null};
/// #
/// # pub type Menu<'a, Message> = iced_aw::native::Menu<'a, Message, Null>;
/// #[derive(Clone, Debug)]
/// enum Message {
///     Entry1,
///     Entry2,
///     Entry3,    
/// }
///
/// let mut menu_state = State::new();
///
/// let menu = Menu::new(&mut menu_state)
///     .push(Section::new(
///         Text::new("Section 1"),
///         vec![
///             Entry::Item(Text::new("Entry 1").into(), Some(Message::Entry1)),
///             Entry::Item(Text::new("Entry 2").into(), Some(Message::Entry2)),
///         ]
///     ))
///     .push(Section::new(
///         Text::new("Section2"),
///         vec![
///             Entry::Item(Text::new("Entry 3").into(), Some(Message::Entry3)),
///         ]
///     ));
/// ```
#[allow(missing_debug_implementations)]
pub struct Cell2<'a, Message, Renderer>
where
    Renderer: self::Renderer,
{
    /// The state of the [`Menu`](Menu).
    state: &'a mut State,
    /// A vector containing the [`Section`](Section)s of the [`Menu`](Menu).
    overlay_entries: Vec<Entry<'a, Message, Renderer>>,
    /// The width of the [`Menu`](Menu).
    width: Length,
    /// The height of the [`Menu`](Menu).
    height: Length,
    /// The space between the [`Section`](Section)s of the [`Menu`](Menu).
    /// Text to be rendered by the [`Cell2`](Cell2)
    item: Element<'a, Message, Renderer>,
    /// Message to be generated by the [`Cell2`](Cell2) when a [`mouse::click::Kind::Single`]
    /// occurs
    on_click: Option<Box<dyn Fn() -> Message>>,
    /// Message to be generated by the [`Cell2`](Cell2) when a double click [`mouse::click::Kind::Double`]
    on_double_click: Option<Box<dyn Fn() -> Message>>,
    /// The [`Style`](crate::style::menu::Style) of the [`Menu`](Menu).
    style: Renderer::Style,
}

impl<'a, Message, Renderer> Cell2<'a, Message, Renderer>
where
    Message: Clone,
    Renderer: self::Renderer,
{
    /// Creates a new [`Menu`](Menu) with an empty list of sections.
    ///
    /// It expects:
    ///     * a mutable reference to the [`Menu`](Menu)'s [`State`](State).
    pub fn new(item: Element<'a, Message, Renderer>, state: &'a mut State) -> Self {
        Cell2::with_entries(item, state, Vec::new())
    }

    /// Creates a new [`Menu`](Menu) with the given list of sections.
    ///
    /// It expects:
    ///     * a mutable reference to the [`Menu`](Menu)'s [`State`](State).
    ///     * a vector containing the sections.
    pub fn with_entries(
        item: Element<'a, Message, Renderer>,
        state: &'a mut State,
        sections: Vec<Entry<'a, Message, Renderer>>,
    ) -> Self {
        Self {
            state,
            overlay_entries: sections,
            width: Length::Fill,
            height: Length::Shrink,
            item,
            style: Renderer::Style::default(),
            on_click: None,
            on_double_click: None,
        }
    }

    /// Sets the style of the [`Menu`](Menu).
    pub fn style(mut self, style: impl Into<Renderer::Style>) -> Self {
        self.style = style.into();
        self
    }
}

impl<'a, Message, Renderer> Widget<Message, Renderer> for Cell2<'a, Message, Renderer>
where
    Message: Clone,
    Renderer: self::Renderer
        + row::Renderer
        + iced_native::text::Renderer
        + crate::widget::overlay::cell_overlay::Renderer, //crate::native::overlay::menu::Renderer,
{
    fn width(&self) -> Length {
        self.width
    }

    fn height(&self) -> Length {
        self.height
    }

    fn layout(&self, renderer: &Renderer, limits: &iced_native::layout::Limits) -> layout::Node {
        self.item.layout(renderer, limits)
    }

    fn on_event(
        &mut self,
        event: Event,
        layout: Layout<'_>,
        cursor_position: Point,
        _renderer: &Renderer,
        _clipboard: &mut dyn Clipboard,
        _messages: &mut Vec<Message>,
    ) -> event::Status {
        let bounds = layout.bounds();
        let children = layout.children();

        if self.state.stack.is_empty() {
            let no_entries = self.overlay_entries.is_empty();
            let status = match event {
                Event::Mouse(mouse::Event::ButtonPressed(mouse::Button::Right)) => {
                    if layout.bounds().contains(cursor_position) && !no_entries {
                        event::Status::Captured
                    } else {
                        event::Status::Ignored
                    }
                }
                _ => event::Status::Ignored,
            };

            if status == event::Status::Captured {
                self.state.stack.push(0);
            }

            status
        } else {
            if bounds.contains(cursor_position) {
                let element = self.overlay_entries.iter().zip(children).enumerate().find(
                    |(_, (section, layout))| {
                        layout.bounds().contains(cursor_position) //&& !section.entries.is_empty()
                    },
                );

                if let Some((i, _)) = element {
                    self.state.stack.clear();
                    self.state.stack.push(i);
                }
            }

            event::Status::Ignored
        }
    }

    fn draw(
        &self,
        renderer: &mut Renderer,
        defaults: &Renderer::Defaults,
        layout: iced_native::Layout<'_>,
        cursor_position: iced_graphics::Point,
        viewport: &iced_graphics::Rectangle,
    ) -> Renderer::Output {
        <Renderer as self::Renderer>::draw(
            renderer,
            DrawEnvironment {
                defaults,
                layout,
                cursor_position,
                style_sheet: &self.style,
                viewport: Some(viewport),
                focus: (),
            },
            &self.item,
        )
    }

    fn hash_layout(&self, state: &mut iced_native::Hasher) {
        #[allow(clippy::missing_docs_in_private_items)]
        self.item.hash_layout(state);
    }

    fn overlay(&mut self, layout: Layout<'_>) -> Option<overlay::Element<'_, Message, Renderer>> {
        if self.state.stack.is_empty() {
            return None;
        }

        let bounds = layout.bounds();

        let position = Point::new(bounds.x, bounds.y + bounds.height);

        Some(Cell2Overlay::new(&mut self.state, &self.overlay_entries, position).overlay())
    }
}

/// The renderer of  a [`Menu`](Menu).
///
/// Your renderer will need to implement this trait before being
/// able to use a [`Menu`](Menu) in your user interface.
pub trait Renderer: iced_native::Renderer {
    /// The style supported by this renderer.
    type Style: Default;

    /// Draws a [`Menu`](Menu).
    fn draw<Message>(
        &mut self,
        env: DrawEnvironment<'_, Self::Defaults, Self::Style, ()>,
        item: &Element<'_, Message, Self>,
    ) -> Self::Output;
}

impl Renderer for iced_native::renderer::Null {
    type Style = ();

    fn draw<Message>(
        &mut self,
        _env: DrawEnvironment<'_, Self::Defaults, Self::Style, ()>,
        item: &Element<'_, Message, Self>,
    ) -> Self::Output {
    }
}

/// The state of the [`Menu`](Menu).
#[derive(Debug, Default)]
pub struct State {
    /// The stack containing the indices that build a path to the opened [`Entry`](Entry).
    pub(crate) stack: Vec<usize>,
    selected: bool,
}

impl State {
    /// Creates a new [`State`](State).
    #[must_use]
    pub const fn new() -> Self {
        Self {
            stack: Vec::new(),
            selected: false,
        }
    }
}

/// An [`Entry`](Entry) of a [`Section`](Section) or `[Entry](Entry)::Group`.
#[allow(missing_debug_implementations)]
pub enum Entry<'a, Message, Renderer> {
    /// An [`Entry`] item holding an [`Element`](iced_native::Element) for it's label
    /// and a message that is send when the item is pressed.
    /// If the message is none the item will be disabled.
    Item(Element<'a, Message, Renderer>, Option<Message>),
    /// An [`Entry`] item that can be toggled.
    Toggle(
        Element<'a, Message, Renderer>,
        bool,
        Option<Box<dyn Fn(bool) -> Message + 'static>>,
    ),
    /// A group of [`Entry`](Entry)s holding an [`Element`](iced_native::Element) for
    /// it's label.
    /// If the vector is empty the group will be disabled.
    Group(
        Element<'a, Message, Renderer>,
        Vec<Entry<'a, Message, Renderer>>,
    ),
    /// A separator.
    Separator,
}

impl<'a, Message, Renderer: iced_native::Renderer> Entry<'a, Message, Renderer> {
    /// Applies a transformation to the produced message of the [`Element`](Element).
    ///
    /// Take a look into the [`Element`](iced_native::Element) documentation for
    /// more information.
    pub fn map<F, B>(self, f: F) -> Entry<'a, B, Renderer>
    where
        Message: 'static,
        Renderer: 'a,
        B: 'static,
        F: 'static + Copy + Fn(Message) -> B,
    {
        match self {
            Entry::Item(label, message) => Entry::Item(label.map(f), message.map(f)),
            Entry::Toggle(label, toggled, message) => Entry::Toggle(
                label.map(f),
                toggled,
                message.map(|m| {
                    // TODO: I can't believe that this actually works...
                    Box::new(move |b: bool| f(m(b))) as Box<dyn Fn(bool) -> B>
                }),
            ),
            Entry::Group(label, entries) => Entry::Group(
                label.map(f),
                entries.into_iter().map(|entry| entry.map(f)).collect(),
            ),
            Entry::Separator => Entry::Separator,
        }
    }
}

impl<'a, Message, Renderer> From<Cell2<'a, Message, Renderer>> for Element<'a, Message, Renderer>
where
    Message: 'a + Clone,
    Renderer: 'a
        + self::Renderer
        + row::Renderer
        + iced_native::text::Renderer
        + crate::widget::overlay::cell_overlay::Renderer,
{
    fn from(menu: Cell2<'a, Message, Renderer>) -> Self {
        Element::new(menu)
    }
}
